'''
1.全局变量与局部变量
'''
#全局变量
x=100
def func():
	print('Inside func: x is {}'.format(x))
func()
print('x is still:{}'.format(x))
# Inside func: x is 100
# x is still:100
# 这个比较好理解x是全局变量，作用域是整个文件,函数内部是可以引用的.接着看下面一个例子：

x=100
def func():
	x=10 #多了这一行
	print ('Changed local x to :{}'.format(x))
func()
print('x is still:{}'.format(x))
# Changed local x to :10
# x is still:100

# 大家看在函数外部有一个变量x,在函数内部也有一个变量x,这两个变量虽然名字长的一样，但是是完全不同的：
# 函数内部的是本地变量，它的生命周期只在函数内部，出了函数就结束了,
# 而x在函数外部模块文件中声明的(python一个文件也叫一个模块)，
# 是全局变量,不会被函数里面的局部变量影响,所以最后print的x还是100

# 有人要问了，有的时候我需要让这个全局变量在函数里面处理，改变它的值，肿么办,这个python早就考虑到了，往下看~~

'''
2.全局变量声明  global
'''
x=100
def func():
	global x #注意加了一个global 关键字，表示x是全局作用域
	print('x is :{}'.format(x))
	x=10
	print ('Changed local x to :{}'.format(x))
func()
print('Value of x:{}'.format(x))
# Changed local x to :10
# Value of x:10

# 这个函数内部多了一个global关键字，结果就差很多：
# 原因在于x被声明为函数内的全局变量，通过global这个语句是自己明确地映射到了模块的作用域
# 函数内对x重新赋值x=10,会改变函数外x的值,所以最后print x是10

# 全局变量简单说就是这3点:
#   全局变量是位于模块文件内部的顶层的变量名
#   全局变量如何是在函数内被改变的话，一定要用global
#   全局变量名在函数内部不经过声明也可以被引用

'''
3.函数内的变量解析原则
有的书上叫LEGB法则，其实讲白了就是下面4个过程，当在函数中使用没有声明过的变量时，
    python的搜索顺序是:
        先是在函数内部的本地作用域(L)  
        然后是在上一层的函数的本地作用域(E)
        然后是全局作用域(G)
        最后是内置作用域(B)

# 简单说就是从局部到中央，好比你找一个人，村里找不到找乡->乡里找不到找市里->市里找不到找到全国档案局
我们来一一解释一下这些原则

1).本地函数
在函数内部(def或者lambda)通过任何方式赋值的，而且没有在该函数内声明为全局变量的变量名

2).上层函数的本地作用域
python函数是支持嵌套，而且多层嵌套，
当你在最里层的函数找不到这个变量的时候，会往上一层的函数找，一层一层由内往外找,举个例子
def f1():
	x=100
	def f2():
		print(x) 
	f2()
print(f1())
>>
100
None 
#因为f2()打印了之后没有return,对没有return的函数就默认返回None
我来解释一下:
def定义了一个f1()函数，里面又嵌套了一个f2()函数,这个def生成了一个函数并将其赋值给变量名f2
f2是f1的本地作用域内的一个本地变量,可以把f2看做一个临时函数,仅仅在f1内部执行的过程中存在.
f2函数干了一件事打印x,当在f2()内部找不到的时候，就通过LEGB法则往上找，f1()里面找到了x.

3).全局(模块)
在模块文件的顶层赋值的变量名，或者在该文件中的def生成的名为全局变量的变量名(函数内global声明的变量)

4).内置的作用域
这个很多初学者不明白，啥内置，内置了什么,其实很简单,python在运行之前会自动的引用一个内置模块，
叫做__builein__,这是python的一个标准库模块，直接import进来，可以用dir(__builein__)看一下，
里面都是预定义的一些变量名

'''